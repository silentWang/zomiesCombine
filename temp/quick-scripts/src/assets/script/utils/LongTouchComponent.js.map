{"version":3,"sources":["assets\\script\\utils\\LongTouchComponent.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["const { ccclass, property } = cc._decorator;\r\n\r\n/**\r\n * @classdesc 长按监听组件\r\n * 1. 将本组件挂载在节点上\r\n * 2. 在属性检查器上设置对应的回调事件\r\n * 3. 长按挂载的节点，那么就会一直回调第2步中设置的事件\r\n *\r\n * @example\r\n *\r\n * ```\r\n *      // 假设第二步回调接受函数为 onTouch() 那么在这个函数的参数如下：\r\n *\r\n *      @param touchCounter 本次触摸次数\r\n *      @param customEventData 在属性检查器中传入进来的 CustomEventData\r\n *\r\n *      onTouch(touchCounter: number, customEventData?: any) { }\r\n *  ```\r\n */\r\n@ccclass\r\nexport default class LongTouchComponent extends cc.Component {\r\n    @property({\r\n        tooltip: \"触摸回调间隔（秒）。假如为0.1，那么1秒内会回调10次 ${longTouchEvents} 事件数组\"\r\n    })\r\n    touchInterval: number = 0.02;\r\n\r\n    @property({\r\n        readonly: true,\r\n        tooltip: \"是否支持多点触控（当前还不支持）\"\r\n    })\r\n    enableMultiTouching: boolean = false;\r\n\r\n    @property({\r\n        type: [cc.Component.EventHandler],\r\n        tooltip: \"回调事件数组，每间隔 ${toucheInterval}s 回调一次\"\r\n    })\r\n    longTouchEvents: cc.Component.EventHandler[] = [];\r\n\r\n    /**\r\n     * 触摸计数器，用于统计本次长按的回调次数\r\n     */\r\n    private _touchCounter: number = 0;\r\n\r\n    /**\r\n     * 标记当前是否在触摸这个节点\r\n     */\r\n    private _isTouching: boolean = false;\r\n\r\n    onEnable() {\r\n        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchStart, this);\r\n        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnd, this);\r\n        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);\r\n\r\n    }\r\n\r\n    onDisable() {\r\n        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchStart, this);\r\n        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnd, this);\r\n        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);\r\n        this.unschedule(this._touchCounterCallback);\r\n    }\r\n\r\n    public clear() {\r\n        this._isTouching = false;\r\n        this.unschedule(this._touchCounterCallback);\r\n    }\r\n\r\n    private _onTouchStart(event: cc.Event.EventTouch) {\r\n        // 这是为了不支持多点触控\r\n        if (!this.enableMultiTouching) {\r\n            if (this._isTouching) {\r\n                return;\r\n            }\r\n\r\n            if (this.node.getBoundingBoxToWorld().contains(event.getLocation())) {\r\n                this._isTouching = true;\r\n            } else {\r\n                this._isTouching = false;\r\n            }\r\n\r\n            if (this._isTouching) {\r\n                // 第一次触摸立即回调一次\r\n                this.publishOneTouch();\r\n\r\n                // 然后开启计时器，计算后续的长按相当于触摸了多少次\r\n                this.node.runAction(cc.sequence(cc.delayTime(0.5), cc.callFunc(() => {\r\n                    if (this._isTouching) {\r\n                        this.unschedule(this._touchCounterCallback);\r\n                        this.schedule(this._touchCounterCallback, this.touchInterval);\r\n                    }\r\n                })))\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onTouchEnd(event: cc.Event.EventTouch) {\r\n        this._isTouching = false;\r\n        this._touchCounter = 0;\r\n        this.unschedule(this._touchCounterCallback);\r\n    }\r\n\r\n    private _onTouchCancel(event: cc.Event.EventTouch) {\r\n        this._isTouching = false;\r\n        this._touchCounter = 0;\r\n        this.unschedule(this._touchCounterCallback);\r\n    }\r\n\r\n    private _touchCounterCallback() {\r\n        if (this._isTouching) {\r\n            this.publishOneTouch();\r\n        } else {\r\n            this.unschedule(this._touchCounterCallback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 通知出去：被点击/触摸了一次，长按时，会连续多次回调这个方法\r\n     */\r\n    private publishOneTouch() {\r\n        if (!this._isTouching) {\r\n            return;\r\n        }\r\n        this.node.runAction(cc.sequence(cc.scaleTo(this.touchInterval / 2, 1.2), cc.scaleTo(this.touchInterval / 2, 1)));\r\n        this._touchCounter++;\r\n        this.longTouchEvents.forEach((eventHandler: cc.Component.EventHandler) => {\r\n            eventHandler.emit([this.node]);\r\n        });\r\n    }\r\n}\r\n"]}